# 310. Minimum Height Trees

For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.

Format
The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

Example 1:

```
Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3
return [1]
```

Example 2:

```
Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5
return [3, 4]
```

how many MHTs can a graph have ? at most 2.
the solution is to remove leaf node(ingree == 1) first, continue this process until there are only(at most ) 2 nodes left.

```java
public class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        
        List<Integer> res = new ArrayList<>();
        if(n == 0) return res;
        if(n == 1){
            res.add(0);
            return res;
        }
        List<List<Integer>> list = new ArrayList<>();
        for(int i=0; i< n; i++){
            list.add(new ArrayList<>());
        }
        int[] ingrees = new int[n];
        for(int[]edge : edges){
            list.get(edge[0]).add(edge[1]);
            ingrees[edge[0]] += 1;
            list.get(edge[1]).add(edge[0]);
            ingrees[edge[1]] += 1;
        }
        Queue<Integer> queue = new LinkedList<>();
        for(int i=0; i< n ;i++){
            if(ingrees[i]== 1) queue.offer(i); 
        }
        
        while(n > 2){ // if there is only two nodes left, there ingree must be 1, which is already int the queue. 
            
            int size = queue.size();
            n -= size;
            for(int i =0; i< size; i++){
                int t = queue.poll();
                for(int adj : list.get(t)){
                    --ingrees[adj];
                    if(ingrees[adj] == 1) queue.offer(adj); // ingree == 1, add to the queue;
                }
            }
            
        }
        res.addAll(queue);
        return res;
        
    }
}
```