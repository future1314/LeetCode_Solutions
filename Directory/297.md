#297. Serialize and Deserialize Binary Tree  

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

For example, you may serialize the following tree

    1
   / \
  2   3
     / \
    4   5
as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.
Wrong Solution.

> if right subtree is way deeper than left, then this won't work.


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null){
            return "[]";
        }
        ArrayList<TreeNode> q = new ArrayList<>();
        
        q.add(root);
        for(int i=0; i<q.size(); i++){
            TreeNode tn = q.get(i);
            if(tn == null) continue;
            q.add(tn.left);
            q.add(tn.right);
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(q.get(0).val);
        while(!q.isEmpty() && q.get(q.size()-1) == null){
            q.remove(q.size()-1);
        }
        for(int i=1; i< q.size(); i++){
            sb.append('#')
                .append(q.get(i) == null ? "A" : q.get(i).val);
        }
        
        return sb.toString();
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("[]")) return null;
        
        String[] vals = data.split("#");
        TreeNode[] nodes = new TreeNode[vals.length];
        for(int i=0; i< vals.length; i++){
            String s = vals[i];
            if(!s.equals("A")){
                nodes[i] = new TreeNode(Integer.parseInt(s));
            }
        }
        int len = nodes.length;
        for(int i=0; i<=len/2; i++){
            TreeNode root = nodes[i];
            if(root == null) continue;
            if(2*i+1 <len)root.left = nodes[2*i+1];
            if(2*i+2 <len)root.right = nodes[2*i +2];
        }
        return nodes[0];
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```


Working Solution
> when serializing happens, you get TreeNode from index i(starting from 0), then add the children into the tail of queue.

>When de-serializing, you process a TreeNode value, you know that its root is in the index i(from 0 too). this is the reverse order of serialzing( BY LOOKING BACK).

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null){
            return "[]";
        }
        ArrayList<TreeNode> q = new ArrayList<>();
        
        q.add(root);
        for(int i=0; i<q.size(); i++){
            TreeNode tn = q.get(i);
            if(tn == null) continue;
            q.add(tn.left);
            q.add(tn.right);
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(q.get(0).val);
        while(!q.isEmpty() && q.get(q.size()-1) == null){
            q.remove(q.size()-1);
        }
        for(int i=1; i< q.size(); i++){
            sb.append('#')
                .append(q.get(i) == null ? "A" : q.get(i).val);
        }
        
        return sb.toString();
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data.equals("[]")) return null;
        
        String[] vals = data.split("#");
        List<TreeNode> list = new ArrayList<>();
        list.add(new TreeNode(Integer.parseInt(vals[0])));
        int index = 0;
        boolean left = true;
        for(int i=1; i< vals.length;i++){
            String v = vals[i];
            if(!v.equals("A")){
                TreeNode tn = new TreeNode(Integer.parseInt(v));
                
                if(left){
                    list.get(index).left = tn;
                }else{
                    list.get(index).right = tn;
                }
                list.add(tn);
            }
            
            if(!left) index++;
            
            left = !left;
        }
        return list.get(0);
       
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```